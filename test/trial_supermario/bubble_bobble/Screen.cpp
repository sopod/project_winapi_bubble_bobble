#include "Screen.h"

Screen::Screen(int _tileSize)
{
	tileSize = _tileSize;
	mapTiles = { 64, 16 };
	visibleTiles = { 30, 10 };

	camera = { 0.0f, 0.0f };
	SetLevel1();

	RangeXPos = { 2, mapTiles.x - 2 };
}

Screen::~Screen()
{
}

std::pair<int, int> Screen::GetRangeXPos()
{
	return RangeXPos;
}

int Screen::GetTileSize()
{
	return tileSize;
}

FPOINT Screen::GetOffset()
{
	return offset;
}

void Screen::SetCamera(FPOINT _pos)
{
	camera = _pos;
}

void Screen::SetLevel1()
{
	
	map = L"................................................................";
	map += L"................................................................";
	map += L"................................................................";
	map += L"................................................................";
	map += L".......................########.................................";
	map += L"......................###..............#.#......................";
	map += L"....................###................#.#......................";
	map += L"...................####.........................................";
	map += L"###################################..##############.....########";
	map += L"........................###########..#...............###........";
	map += L"........................#............#............###...........";
	map += L"........................#............#.........###..............";
	map += L"........................#..###########......###.................";
	map += L"........................#................###....................";
	map += L"........................#..............##.......................";
	map += L"........................##################......................";
	
	/*
	map = L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";

	map += L"...#######......................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";
	*/
	/*
	map = L"................................";
	map += L"................................";
	map += L"................................";
	map += L"................................";

	map += L"################################";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"####....################....####";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"####....################....####";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"####....################....####";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"##............................##";
	map += L"################################";*/
}

wchar_t Screen::GetTileFromIdx(int x, int y)
{
	if (x >= 0 && x < mapTiles.x && y >= 0 && y < mapTiles.y)
		return map[y * mapTiles.x + x];
	else
		return L' ';
}

void Screen::SetTileFromIdx(int x, int y, wchar_t c)
{
	if (x >= 0 && x < mapTiles.x && y >= 0 && y < mapTiles.y)
		map[y * mapTiles.x + x] = c;
}

void Screen::DrawMap(Graphics * graphic)
{
	// 전체 맵에서 화면의 좌상단까지의 오프셋	
	offset.x = camera.x - visibleTiles.x / 2.0f;
	offset.y = camera.y - visibleTiles.y / 2.0f;

	// 화면은 맵 안에서만 움직이자
	if (offset.x < 0) offset.x = 0;
	if (offset.y < 0) offset.y = 0;
	if (offset.x > mapTiles.x - visibleTiles.x) offset.x = mapTiles.x - visibleTiles.x;
	if (offset.y > mapTiles.y - visibleTiles.y) offset.y = mapTiles.y - visibleTiles.y;

	// 화면의 타일 오프셋	
	tileOffset.x = (offset.x - (int)offset.x) * tileSize;
	tileOffset.y = (offset.y - (int)offset.y) * tileSize;
	

	SolidBrush brush1(Color(255, 0, 0, 0));
	SolidBrush brush2(Color(255, 255, 0, 0));

	for (int x = 0; x < mapTiles.x; x++)
	{
		for (int y = 0; y < mapTiles.y; y++)
		{
			wchar_t curTile = GetTileFromIdx(x + offset.x, y + offset.y);
			switch (curTile)
			{
			case L'.':
				graphic->FillRectangle(&brush1, (int)(x * tileSize - tileOffset.x), (int)(y * tileSize - tileOffset.y), tileSize, tileSize); // 좌상단
				break;

			case L'#':
				graphic->FillRectangle(&brush2, (int)(x * tileSize - tileOffset.x), (int)(y * tileSize - tileOffset.y), tileSize, tileSize);
				break;
			}
		}
	}
}
